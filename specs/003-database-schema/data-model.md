# Data Model: Database Schema and Persistence

**Feature**: 003-database-schema
**Created**: 2026-02-06
**Implementation**: `backend/models.py`

## Entity Definitions

### User Entity

**Purpose**: Stores authenticated user accounts

**Location**: `backend/models.py:14-43`

**Fields**:

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | string (UUID) | PRIMARY KEY | Unique identifier (generated by Better Auth) |
| email | string | UNIQUE, NOT NULL, INDEX | User's email address for authentication |
| password_hash | string | NOT NULL | Hashed password (bcrypt/argon2 via Better Auth) |
| name | string | NULLABLE | Optional user display name |
| created_at | datetime | NOT NULL | Account creation timestamp (UTC) |
| updated_at | datetime | NOT NULL | Last account update timestamp (UTC) |

**Relationships**:
- One User → Many Tasks (one-to-many)

**Indexes**:
- PRIMARY KEY on id (automatic)
- INDEX on email (for fast login lookups)

**Constraints**:
- UNIQUE(email) - Prevents duplicate email registration
- NOT NULL(email, password_hash) - Required fields
- Default timezone: UTC for all timestamps

**Table Name**: `users`

---

### Task Entity

**Purpose**: Stores todo items with user ownership

**Location**: `backend/models.py:46-70`

**Fields**:

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | integer | PRIMARY KEY, AUTO_INCREMENT | Unique task identifier |
| user_id | string (UUID) | FOREIGN KEY, NOT NULL, INDEX | Owner's user ID (references users.id) |
| title | string | NOT NULL, MAX_LENGTH(200) | Task title/summary |
| description | string | NULLABLE, MAX_LENGTH(1000) | Optional task description |
| completed | boolean | NOT NULL, DEFAULT(false) | Task completion status |
| created_at | datetime | NOT NULL | Task creation timestamp (UTC) |
| updated_at | datetime | NOT NULL | Last task update timestamp (UTC) |

**Relationships**:
- Many Tasks → One User (many-to-one via user_id foreign key)

**Indexes**:
- PRIMARY KEY on id (automatic)
- INDEX on user_id (for fast user-specific queries)

**Constraints**:
- FOREIGN KEY(user_id) REFERENCES users(id) - Enforces referential integrity
- NOT NULL(user_id, title) - Required fields
- DEFAULT(completed) = false - New tasks start incomplete
- MAX_LENGTH constraints enforce data limits

**Table Name**: `tasks`

---

## Entity Relationships

### User-Task Relationship

**Type**: One-to-Many

**Cardinality**: 1 User → 0..N Tasks

**Foreign Key**: tasks.user_id → users.id

**Cascade Behavior**: None defined (user deletion out of scope for Phase II)

**Query Pattern**:
```sql
-- Get all tasks for a user (most common query)
SELECT * FROM tasks WHERE user_id = ? ORDER BY created_at DESC;

-- Get specific task with ownership verification
SELECT * FROM tasks WHERE id = ? AND user_id = ?;
```

**Index Usage**:
- tasks.user_id index speeds up user-specific queries
- Covering index on (user_id, created_at) would further optimize (future enhancement)

---

## Database Schema Diagram

```
┌──────────────────────────────┐
│          User                │
├──────────────────────────────┤
│ id: UUID (PK)                │
│ email: string (unique, idx)  │◄─────┐
│ password_hash: string        │      │
│ name: string | null          │      │
│ created_at: datetime         │      │
│ updated_at: datetime         │      │
└──────────────────────────────┘      │
                                      │ FK
                               ┌──────┴──────┐
                               │ user_id     │
┌──────────────────────────────┴─────────────┐
│          Task                              │
├────────────────────────────────────────────┤
│ id: integer (PK, auto-increment)           │
│ user_id: UUID (FK → users.id, idx)         │
│ title: string (max 200, required)          │
│ description: string | null (max 1000)      │
│ completed: boolean (default false)         │
│ created_at: datetime                       │
│ updated_at: datetime                       │
└────────────────────────────────────────────┘
```

---

## SQLModel Implementation

### User Model (backend/models.py)

```python
class User(SQLModel, table=True):
    __tablename__ = "users"

    id: Optional[str] = Field(default=None, primary_key=True)
    email: str = Field(unique=True, nullable=False, index=True)
    password_hash: str = Field(nullable=False)
    name: Optional[str] = Field(default=None)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

### Task Model (backend/models.py)

```python
class Task(SQLModel, table=True):
    __tablename__ = "tasks"

    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: str = Field(index=True, nullable=False, foreign_key="users.id")
    title: str = Field(max_length=200, nullable=False)
    description: Optional[str] = Field(default=None, max_length=1000)
    completed: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

---

## Performance Considerations

### Indexes

**users.email**:
- Speeds up signin queries (email lookup)
- Enforces uniqueness at database level
- Used in: Authentication queries

**tasks.user_id**:
- Speeds up user-specific task queries (most common operation)
- Used in: List tasks, count tasks, filter by user

### Query Performance

**Expected Performance** (from spec SC-003):
- Target: <100ms for 10,000 tasks per user
- Index on user_id makes this achievable
- Additional optimization: Add composite index on (user_id, created_at) for sorted queries

### Connection Pooling

**Configuration** (backend/main.py):
- pool_size=5: Normal concurrent connections
- max_overflow=10: Burst capacity (total 15 connections)
- pool_pre_ping=True: Validates connections before use (critical for Neon serverless)

---

## Constitution Compliance

### Section II: Architectural Boundaries

✅ **SQLModel ORM Only**:
- All queries use SQLModel select/insert/update/delete
- No raw SQL in application code
- Parameterized queries prevent SQL injection

### Section III: Security-By-Design

✅ **User Isolation**:
- Every task has user_id field (indexed)
- Foreign key enforces referential integrity
- All queries filter by user_id

✅ **Data Integrity**:
- NOT NULL constraints on required fields
- Unique constraint on email
- Foreign key prevents orphaned tasks

### Technology Stack

✅ **Mandatory Technologies**:
- Neon Serverless PostgreSQL (no alternatives)
- SQLModel ORM (no raw SQL, no other ORMs)
- Connection pooling configured correctly

---

## Validation Criteria

### Schema Validation

- ✅ User table has all required fields (6 fields)
- ✅ Task table has all required fields (7 fields)
- ✅ Foreign key relationship exists
- ✅ Indexes created on email and user_id
- ✅ Constraints enforced (unique, NOT NULL, max_length)

### Functional Validation

- ✅ Data persists across application restarts
- ✅ User isolation works (users see only their tasks)
- ✅ Timestamps automatically set on create/update
- ✅ Foreign key prevents invalid user_id values
- ✅ Email uniqueness enforced

### Performance Validation

- Query performance: <100ms for large datasets
- Connection pooling: Handles concurrent requests
- Index usage: Queries use indexes effectively

---

## Next Steps

1. **Run `/sp.tasks`**: Generate validation tasks to verify implementation
2. **Test Database**: Connect to Neon, verify tables created correctly
3. **Validate Constraints**: Test unique email, foreign key, NOT NULL
4. **Move to Feature 004**: Task CRUD API endpoints (uses these models)

**Status**: Models implemented and appear compliant. Ready for validation and integration with API layer.
