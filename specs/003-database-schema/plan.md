# Implementation Plan: Database Schema and Persistence

**Branch**: `003-database-schema` | **Date**: 2026-02-06 | **Spec**: [spec.md](./spec.md)

**Plan Type**: **Validation Plan** (models already implemented in Feature 002)

## Summary

This plan validates the existing database schema implementation in `backend/models.py` against specification requirements (FR-001 to FR-015). The User and Task models were created during Feature 002 (Authentication, Phase 2). This plan documents the schema, verifies constitution compliance, and establishes validation criteria.

## Technical Context

**Language/Version**: Python 3.11+
**Primary Dependencies**: SQLModel 0.0.32, psycopg2-binary 2.9.9, FastAPI 0.110.0
**Storage**: Neon Serverless PostgreSQL (connection via DATABASE_URL)
**Testing**: Manual validation via database queries and model inspection
**Target Platform**: Linux/Windows server, Python runtime
**Project Type**: Web application (backend/database layer)
**Performance Goals**: <100ms queries for 10,000 tasks/user, connection pool handles 15 concurrent connections
**Constraints**: SQLModel ORM only (no raw SQL), pool_pre_ping=True for serverless, UTC timestamps
**Scale/Scope**: Multi-user (100-10,000 users), unlimited tasks per user, two tables (users, tasks)

## Constitution Check

✅ **Section I: Spec-First Development**
- Specification created (retroactive documentation of implementation)
- All future schema changes require spec updates

✅ **Section II: Strict Architectural Boundaries**
- Database accessed ONLY via SQLModel ORM ✓
- No raw SQL in application code ✓
- Backend owns all database operations ✓
- Frontend communicates via REST API only ✓

✅ **Section III: Security-By-Design**
- User isolation: tasks.user_id field (indexed, foreign key) ✓
- NOT NULL on user_id (cannot create orphaned tasks) ✓
- Foreign key constraint enforces referential integrity ✓
- Email unique constraint (prevents duplicate accounts) ✓

✅ **Technology Stack Standards**
- Neon Serverless PostgreSQL (mandatory) ✓
- SQLModel ORM (mandatory, no alternatives) ✓
- Connection pooling with pool_pre_ping=True ✓

**Gate Status**: ✅ **PASSED** - All constitution requirements met by existing implementation

## Project Structure

### Documentation (this feature)

```text
specs/003-database-schema/
├── spec.md              # Feature specification (completed)
├── plan.md              # This validation plan
├── data-model.md        # Entity documentation (Phase 1)
└── tasks.md             # Validation tasks (/sp.tasks)
```

### Source Code (already implemented)

```text
backend/
├── models.py            # ✅ User and Task SQLModel classes (70 lines)
├── main.py              # ✅ Database engine, initialization (120 lines)
├── auth.py              # JWT verification (Feature 002)
└── .env                 # DATABASE_URL configuration
```

## Phase 0: Research (Not Required)

**Status**: ✅ **COMPLETE** - No research needed

**Rationale**: Models already implemented following constitution and industry best practices:
- SQLModel: Combines SQLAlchemy ORM with Pydantic validation
- Neon: Serverless PostgreSQL with automatic scaling
- Connection pooling: Configured for serverless (pool_pre_ping validates connections)
- Indexes: Created on frequently queried fields (email, user_id)
- Timestamps: Automatic via datetime.utcnow default factory

## Phase 1: Data Model Documentation

### data-model.md

**User Entity** (backend/models.py:14-43):
```
User
├── id: string (UUID, primary key)
│   └── Generated by Better Auth
├── email: string
│   ├── unique=True (prevents duplicates)
│   ├── nullable=False (required)
│   └── index=True (fast lookups)
├── password_hash: string
│   ├── nullable=False (required)
│   └── Hashed by Better Auth (bcrypt/argon2)
├── name: string | null (optional)
├── created_at: datetime (UTC, auto-set on creation)
└── updated_at: datetime (UTC, auto-update on modification)

Relationships:
- One User → Many Tasks

Constraints:
- PRIMARY KEY(id)
- UNIQUE(email)
- NOT NULL(email, password_hash)
- INDEX(email)

Table: "users"
```

**Task Entity** (backend/models.py:46-70):
```
Task
├── id: integer (auto-increment, primary key)
├── user_id: string (UUID, foreign key → users.id)
│   ├── index=True (fast user filtering)
│   └── nullable=False (required)
├── title: string
│   ├── max_length=200
│   └── nullable=False (required)
├── description: string | null
│   └── max_length=1000 (optional)
├── completed: boolean (default=False)
├── created_at: datetime (UTC, auto-set on creation)
└── updated_at: datetime (UTC, auto-update on modification)

Relationships:
- Many Tasks → One User

Constraints:
- PRIMARY KEY(id)
- FOREIGN KEY(user_id) REFERENCES users(id)
- NOT NULL(user_id, title)
- INDEX(user_id)
- DEFAULT(completed) = false

Table: "tasks"
```

**Database Schema Diagram:**
```
┌──────────────────────┐
│       User           │
├──────────────────────┤
│ id (UUID, PK)        │
│ email (unique, idx)  │
│ password_hash        │
│ name (optional)      │
│ created_at           │
│ updated_at           │
└───────────┬──────────┘
            │ 1
            │
            │ N
┌───────────┴──────────┐
│       Task           │
├──────────────────────┤
│ id (int, PK)         │
│ user_id (FK, idx)    │
│ title (max 200)      │
│ description (1000)   │
│ completed (bool)     │
│ created_at           │
│ updated_at           │
└──────────────────────┘
```

### Validation Checklist

✅ FR-001: User fields present (id, email, password_hash, name, timestamps)
✅ FR-002: Email unique constraint enforced
✅ FR-003: Task fields present (id, user_id, title, description, completed, timestamps)
✅ FR-004: Foreign key tasks.user_id → users.id
✅ FR-005: NOT NULL on title and user_id
✅ FR-006: Default false on completed
✅ FR-007: Indexes on email and user_id
✅ FR-008: created_at auto-set (default_factory=datetime.utcnow)
✅ FR-009: updated_at auto-update (application responsibility)
✅ FR-010: Title max length 200
✅ FR-011: Description max length 1000
✅ FR-012: SQLModel ORM used (no raw SQL)
✅ FR-013: Neon PostgreSQL configured
✅ FR-014: Tables initialized on startup (main.py:73-80)
✅ FR-015: Connection pooling (pool_pre_ping=True, pool_size=5)

## Phase 2: Next Steps

Run `/sp.tasks` to generate validation tasks that verify the implementation against these requirements.

**Validation Tasks Will Include:**
1. Inspect models.py structure
2. Verify database table creation
3. Test foreign key constraints
4. Validate index creation
5. Test timestamp automation
6. Verify connection pooling
7. Confirm no raw SQL in codebase

## Success Criteria

This validation plan succeeds when:
- ✅ All 15 FR requirements verified in existing code
- ✅ Constitution compliance confirmed
- ✅ Schema documentation complete (data-model.md)
- ✅ Validation tasks ready for execution

**Current Status**: Models exist and appear constitution-compliant. Awaiting validation task execution.
