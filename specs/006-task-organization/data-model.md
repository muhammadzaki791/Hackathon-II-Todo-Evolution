# Data Model: Task Organization & Usability Enhancements

**Feature**: 006-task-organization
**Date**: 2026-02-08
**Related**: [spec.md](./spec.md), [plan.md](./plan.md)

## Overview

This document defines the data model changes for adding task organization features (priority, tags, search, filters, sorting) to the existing Todo application. Changes are **backward compatible** - existing tasks continue to function with default values.

## Entities

### Task (Modified)

**Description**: Represents a user's to-do item with organization and categorization capabilities.

**Storage**: PostgreSQL table `tasks` (existing - adding 2 new columns)

**Attributes**:

| Field | Type | Constraints | Default | Description |
|-------|------|-------------|---------|-------------|
| id | Integer | PRIMARY KEY, AUTO INCREMENT | - | Unique task identifier |
| user_id | String | NOT NULL, INDEXED, FK → User.id | - | Owner of the task (for user isolation) |
| title | String (200) | NOT NULL, MIN LENGTH 1 | - | Task title/summary |
| description | String (1000) | NULLABLE | NULL | Detailed task description |
| completed | Boolean | NOT NULL | false | Completion status |
| **priority** | **String (enum)** | **NOT NULL, ENUM('high', 'medium', 'low')** | **'medium'** | **Task priority level (NEW)** |
| **tags** | **JSON Array** | **NOT NULL** | **[]** | **Array of tag strings (NEW)** |
| created_at | DateTime (UTC) | NOT NULL | NOW() | Creation timestamp |
| updated_at | DateTime (UTC) | NOT NULL | NOW() | Last modification timestamp |

**Indexes**:
- `PRIMARY KEY (id)` - existing
- `INDEX (user_id)` - existing (for user isolation queries)
- `INDEX (priority)` - NEW (for priority-based filtering and sorting)
- `GIN INDEX (tags)` - NEW (for tag containment queries)
- `GIN INDEX (title gin_trgm_ops)` - OPTIONAL (for ILIKE search performance)
- `GIN INDEX (description gin_trgm_ops)` - OPTIONAL (for ILIKE search performance)

**Relationships**:
- **Belongs to**: User (via `user_id` foreign key)
- **Relationship**: One user has many tasks
- **Isolation**: All queries MUST filter by authenticated `user_id`

**Validation Rules**:

- **id**: Auto-generated by database
- **user_id**: Extracted from JWT token (never from client input)
- **title**: 1-200 characters (trimmed, non-empty)
- **description**: 0-1000 characters (nullable, optional)
- **completed**: Boolean (default false)
- **priority**: Must be one of: `"high"`, `"medium"`, `"low"` (validated by Pydantic)
- **tags**: Array of strings, each tag 1-50 characters, max 20 tags per task
- **created_at**: Set once on creation (immutable)
- **updated_at**: Updated on every modification

**State Transitions**:

```text
Task Lifecycle:
1. Created → completed=false, priority="medium", tags=[]
2. Updated → priority can change, tags can be added/removed
3. Completed → completed=true (can be toggled back to false)
4. Deleted → Row removed from database

Priority Transitions:
- high ↔ medium ↔ low (any direction allowed)

Tag Transitions:
- Add tag: tags.append(new_tag) if not exists
- Remove tag: tags.remove(tag) if exists
- Replace tags: tags = new_tag_list
```

**Backward Compatibility**:
- **Existing tasks** (created before this feature):
  - Automatically receive `priority="medium"` via server_default
  - Automatically receive `tags=[]` via server_default
  - No manual data migration required
  - Continue to function identically in UI

- **API behavior**:
  - GET requests: Return priority and tags for all tasks (defaults applied)
  - POST/PUT requests: Accept priority and tags (optional, default if omitted)
  - Existing client code: Works unchanged (defaults applied server-side)

---

### TaskQueryParams (New - Not Stored)

**Description**: Represents search, filter, and sort parameters for task queries. This is a **data transfer object** (DTO) used in API requests, not stored in database.

**Usage**: Query parameters for `GET /api/{user_id}/tasks`

**Attributes**:

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| search | String (optional) | null | Keyword to search in title/description (case-insensitive) |
| status | Enum (optional) | null | Filter by completion status: "pending", "completed" |
| priority | Enum (optional) | null | Filter by priority level: "high", "medium", "low" |
| tags | String (optional) | null | Filter by tag (single tag, comma-separated for multiple) |
| sort | Enum (optional) | "date" | Sort order: "date" (newest first), "alpha" (A-Z), "priority" (high→low) |

**Validation Rules**:
- **search**: 0-100 characters, trimmed, null if empty
- **status**: Must be "pending" or "completed" if provided
- **priority**: Must be "high", "medium", or "low" if provided
- **tags**: Tag name(s), single tag or comma-separated list
- **sort**: Must be "date", "alpha", or "priority" if provided

**Query Combination Logic**:
- **AND logic**: All specified filters must match (e.g., status=pending AND priority=high AND search="meeting")
- **Empty filters**: If no filters specified, return all user's tasks
- **Sort precedence**: Applied after filtering (only sorts visible tasks)

**Example Queries**:
```
GET /api/user-123/tasks?search=groceries
→ Returns tasks where title or description contains "groceries"

GET /api/user-123/tasks?status=pending&priority=high
→ Returns high-priority pending tasks

GET /api/user-123/tasks?tags=work&sort=priority
→ Returns tasks with "work" tag, sorted by priority

GET /api/user-123/tasks?search=meeting&status=pending&priority=high&sort=date
→ Returns high-priority pending tasks containing "meeting", sorted by newest first
```

---

## Database Schema Changes

### Migration Summary

**Changes to Task Table**:
1. Add `priority` column: VARCHAR with server default "medium"
2. Add `tags` column: JSON with server default "[]"

**SQL Equivalent** (for reference - SQLModel handles this):
```sql
-- Add priority column
ALTER TABLE tasks
ADD COLUMN priority VARCHAR(10) NOT NULL DEFAULT 'medium'
CHECK (priority IN ('high', 'medium', 'low'));

-- Add tags column
ALTER TABLE tasks
ADD COLUMN tags JSON NOT NULL DEFAULT '[]'::json;

-- Add indexes
CREATE INDEX idx_task_priority ON tasks(priority);
CREATE INDEX idx_task_tags_gin ON tasks USING gin(tags);
```

**Rollback Plan** (if needed):
```sql
-- Remove columns
ALTER TABLE tasks DROP COLUMN priority;
ALTER TABLE tasks DROP COLUMN tags;

-- Drop indexes
DROP INDEX IF EXISTS idx_task_priority;
DROP INDEX IF EXISTS idx_task_tags_gin;
```

---

## Data Flow

### Create Task with Priority and Tags

```text
1. User fills TaskForm → title="Buy groceries", priority="high", tags=["shopping", "urgent"]
2. Frontend validates inputs → title length, priority enum, tags array
3. Frontend calls API → POST /api/{user_id}/tasks with JSON body
4. Backend validates via Pydantic → TaskCreate schema
5. Backend creates Task model instance → priority="high", tags=["shopping", "urgent"]
6. SQLModel inserts row → Database stores JSON array
7. Backend returns TaskResponse → Includes priority and tags
8. Frontend updates task list → New task appears with red priority badge and tag chips
```

### Search Tasks

```text
1. User types in SearchBar → "meeting"
2. Frontend debounces input → Waits 300ms after typing stops
3. Frontend calls API → GET /api/{user_id}/tasks?search=meeting
4. Backend builds query → WHERE (title ILIKE '%meeting%' OR description ILIKE '%meeting%') AND user_id = {authenticated_user}
5. Database executes query → Returns matching rows
6. Backend returns filtered tasks → JSON array
7. Frontend displays results → Only matching tasks shown
```

### Filter by Priority and Status

```text
1. User selects filters → Status="pending", Priority="high"
2. Frontend updates state → statusFilter="pending", priorityFilter="high"
3. Frontend calls API → GET /api/{user_id}/tasks?status=pending&priority=high
4. Backend builds query → WHERE completed=false AND priority='high' AND user_id={user}
5. Database executes query → Returns matching rows
6. Backend returns filtered tasks → JSON array
7. Frontend displays results → Only high-priority pending tasks shown
```

### Sort Tasks

```text
1. User selects sort option → "Priority (High to Low)"
2. Frontend updates state → sortOrder="priority"
3. Frontend calls API → GET /api/{user_id}/tasks?sort=priority
4. Backend builds query → ORDER BY CASE priority WHEN 'high' THEN 1 WHEN 'medium' THEN 2 WHEN 'low' THEN 3 END, created_at DESC
5. Database executes query → Returns sorted rows
6. Backend returns ordered tasks → JSON array
7. Frontend displays results → Tasks reordered (high→medium→low, then by date within each priority)
```

---

## Backward Compatibility Verification

### Existing Task Scenarios

**Scenario 1: Task created before priority/tags feature**
```json
// Database row (before feature)
{
  "id": 123,
  "user_id": "user-abc",
  "title": "Old task",
  "description": "Created last week",
  "completed": false,
  "created_at": "2026-02-01T10:00:00Z",
  "updated_at": "2026-02-01T10:00:00Z"
  // priority and tags columns don't exist yet
}

// After migration (server defaults applied)
{
  "id": 123,
  "user_id": "user-abc",
  "title": "Old task",
  "description": "Created last week",
  "completed": false,
  "priority": "medium",  // ← server_default applied
  "tags": [],            // ← server_default applied
  "created_at": "2026-02-01T10:00:00Z",
  "updated_at": "2026-02-01T10:00:00Z"
}

// Frontend behavior
- Task displays with yellow "Medium" priority badge
- Task displays with no tags (graceful empty state)
- User can edit task to change priority or add tags
```

**Scenario 2: API calls from old frontend code**
```javascript
// Old API call (doesn't send priority/tags)
POST /api/{user_id}/tasks
Body: { "title": "New task", "description": "Details" }

// Backend behavior (Pydantic with defaults)
- TaskCreate schema: priority defaults to "medium", tags defaults to []
- Task model receives: { title, description, priority="medium", tags=[] }
- Database stores: Complete task with defaults
- Response: Returns task with priority="medium", tags=[]

// Frontend behavior
- Task appears with "Medium" priority badge
- Task appears with no tags
- Fully functional
```

---

## Performance Considerations

### Query Performance

**Baseline** (no filters):
```sql
SELECT * FROM tasks WHERE user_id = 'user-123' ORDER BY created_at DESC;
-- Expected: <10ms for 100 tasks, <50ms for 500 tasks
```

**With Search**:
```sql
SELECT * FROM tasks
WHERE user_id = 'user-123'
  AND (title ILIKE '%keyword%' OR description ILIKE '%keyword%')
ORDER BY created_at DESC;
-- Expected: <100ms for 500 tasks (without index), <20ms (with trigram index)
```

**With Multiple Filters**:
```sql
SELECT * FROM tasks
WHERE user_id = 'user-123'
  AND completed = false
  AND priority = 'high'
  AND tags @> '["work"]'::jsonb
ORDER BY
  CASE priority WHEN 'high' THEN 1 WHEN 'medium' THEN 2 WHEN 'low' THEN 3 END,
  created_at DESC;
-- Expected: <50ms for 500 tasks (with indexes)
```

### Index Strategy Priority

**Required** (implement first):
1. `INDEX (priority)` - Fast priority filtering and sorting
2. `GIN INDEX (tags)` - Fast tag containment queries

**Optional** (add if performance issues arise):
3. `GIN INDEX (title gin_trgm_ops)` - Faster ILIKE search on title
4. `GIN INDEX (description gin_trgm_ops)` - Faster ILIKE search on description

**Monitoring**: Track query performance via FastAPI logging. Add trigram indexes if search queries exceed 100ms consistently.

---

## Data Model Summary

**Changes**:
- ✅ 2 new fields added to Task model (priority, tags)
- ✅ Default values ensure backward compatibility
- ✅ JSON storage for tags (flexible, indexed)
- ✅ Priority enum validated at application layer
- ✅ Query parameters defined for search/filter/sort
- ✅ Performance targets met with standard indexes

**Validation**: All changes maintain existing functionality while adding new capabilities.

**Next Phase**: Define API contracts with query parameter specifications.
